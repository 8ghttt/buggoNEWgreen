<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xbox Controller Overlay Optimized with 5-Stack 3D Sticks (FINAL WORKING CODE)</title>
    <style>
        /* --- Base Styles --- */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: transparent; 
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        .container {
            text-align: center;
            position: relative;
        }

        .controller-wrapper {
            position: relative;
            display: inline-block;
            width: 1310px;
            height: 932px;
        }

        /* --- Controller Base and Buttons --- */
        .controller.xbox {
            background: url(base2.gif);
            width: 1310px;
            height: 932px;
            background-repeat: no-repeat;
            background-size: contain;
            background-position: center;
            position: absolute;
        }

        .xbox .triggers, .xbox .trigger, .xbox .bumpers, .xbox .bumper, 
        .xbox .arrows, .xbox .back, .xbox .start, .xbox .abxy, .xbox .button, 
        .xbox .dpad, .xbox .face {
            width: 1310px;
            height: 932px;
            position: absolute;
            background-repeat: no-repeat;
            background-size: contain;
            background-position: center;
        }
        
        .xbox .trigger.left { background-image: url(LT.png); }
        .xbox .trigger.right { background-image: url(RT.png); }
        .xbox .bumper.left { background-image: url(LB.png); }
        .xbox .bumper.right { background-image: url(RB.png); }
        .xbox .back { background-image: url(Select.png); }
        .xbox .start { background-image: url(Start.png); }
        .xbox .a { background-image: url(A.png); }
        .xbox .b { background-image: url(B.png); }
        .xbox .x { background-image: url(X.png); }
        .xbox .y { background-image: url(Y.png); }
        .xbox .face.up { background-image: url(Up.png); }
        .xbox .face.down { background-image: url(Down.png); }
        .xbox .face.left { background-image: url(Left.png); }
        .xbox .face.right { background-image: url(Right.png); }

        .xbox .trigger, .xbox .bumper, .xbox .back, .xbox .start, .xbox .button, .xbox .face {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .xbox .trigger.pressed, .xbox .bumper.pressed, .xbox .back.pressed, .xbox .start.pressed, .xbox .button.pressed, .xbox .face.pressed {
            opacity: 1;
        }

        /* --- STICK WRAPPER (No 3D Perspective here anymore) --- */
        .xbox .sticks {
            position: absolute;
            width: 1310px;
            height: 932px;
            top: 0px;
            left: 0px;
        }

        /* --- INDIVIDUAL STICK CONTAINERS for Local Perspective --- */
        .stick-container {
            position: absolute;
            width: 150px; 
            height: 150px; 
            perspective: 600px; /* LOCAL 3D perspective */
            transform-style: preserve-3d;
        }
        
        /* Position the small left container using the final coordinates */
        .stick-container.left {
            top: 503px; 
            left: 468px; 
        }

        /* Position the small right container using the final coordinates */
        .stick-container.right {
            top: 503px; 
            left: 688px; 
        }

        /* --- STICK LAYERS (Now relative to their small container) --- */
        .xbox .stick {
            position: absolute;
            width: 150px; 
            height: 150px;
            background-size: cover; 
            background-position: center;
            transform-origin: center center; 
            transition: transform 0.05s linear; 
            will-change: transform;
            /* STARTING POSITION: 0, 0 is the top-left of the 150x150 container */
            top: 0px; 
            left: 0px; 
        }

        /* Set z-index for stacking order (0 is bottom, 4 is top) */
        .xbox .stick.shadow-0 { z-index: 0; } 
        .xbox .stick.shadow-1 { z-index: 1; } 
        .xbox .stick.shadow-2 { z-index: 2; }
        .xbox .stick.shadow-3 { z-index: 3; }
        .xbox .stick.main { z-index: 4; }

        .xbox .stick.left { background-image: url(LSidle.png); }
        .xbox .stick.right { background-image: url(RSidle.png); }

        .xbox .stick.main.pressed.left { background-image: url(LS.png); }
        .xbox .stick.main.pressed.right { background-image: url(RS.png); }
    </style>
</head>
<body>
    <div class="container">
        <div class="controller-wrapper">
            <div class="controller xbox">
                <div class="triggers"><div class="trigger left"></div><div class="trigger right"></div></div>
                <div class="bumpers"><div class="bumper left"></div><div class="bumper right"></div></div>
                <div class="arrows"><div class="back"></div><div class="start"></div></div>
                <div class="abxy"><div class="button a"></div><div class="button b"></div><div class="button x"></div><div class="button y"></div></div>
                
                <div class="sticks">
                    <div class="stick-container left">
                        <div class="stick shadow-0 left"></div> 
                        <div class="stick shadow-1 left"></div>
                        <div class="stick shadow-2 left"></div>
                        <div class="stick shadow-3 left"></div>
                        <div class="stick main left"></div>
                    </div>
                    
                    <div class="stick-container right">
                        <div class="stick shadow-0 right"></div>
                        <div class="stick shadow-1 right"></div>
                        <div class="stick shadow-2 right"></div>
                        <div class="stick shadow-3 right"></div>
                        <div class="stick main right"></div>
                    </div>
                </div>
                
                <div class="dpad"><div class="face up"></div><div class="face down"></div><div class="face left"></div><div class="face right"></div></div>
            </div>
        </div>
    </div>

    <script>
        let gamepadIndex = null;
        
        const buttonMap = {
            0: '.a', 1: '.b', 2: '.x', 3: '.y', 4: '.bumper.left', 5: '.bumper.right', 
            6: '.trigger.left', 7: '.trigger.right', 8: '.back', 9: '.start', 
            10: '.stick.main.left', 11: '.stick.main.right', 
            // D-pad buttons (12-15) are handled explicitly below
        };

        const controllerElements = {};
        const buttonSelectors = Object.values(buttonMap);
        
        buttonSelectors.forEach(selector => {
            if (!selector.includes('.stick')) {
                controllerElements[selector] = document.querySelector(selector);
            }
        });
        
        // Explicitly get D-pad elements for axis/button check
        controllerElements['.face.up'] = document.querySelector('.face.up');
        controllerElements['.face.down'] = document.querySelector('.face.down');
        controllerElements['.face.left'] = document.querySelector('.face.left');
        controllerElements['.face.right'] = document.querySelector('.face.right');

        const leftStickLayers = [
            document.querySelector('.stick-container.left .stick.main.left'),
            document.querySelector('.stick-container.left .stick.shadow-3.left'),
            document.querySelector('.stick-container.left .stick.shadow-2.left'),
            document.querySelector('.stick-container.left .stick.shadow-1.left'),
            document.querySelector('.stick-container.left .stick.shadow-0.left'),
        ];
        const rightStickLayers = [
            document.querySelector('.stick-container.right .stick.main.right'),
            document.querySelector('.stick-container.right .stick.shadow-3.right'),
            document.querySelector('.stick-container.right .stick.shadow-2.right'),
            document.querySelector('.stick-container.right .stick.shadow-1.right'),
            document.querySelector('.stick-container.right .stick.shadow-0.right'),
        ];
        
        function connectHandler(e) {
            gamepadIndex = e.gamepad.index;
            setInitialStickTransforms();
            requestAnimationFrame(updateStatus);
        }

        function disconnectHandler(e) {
            if (gamepadIndex === e.gamepad.index) {
                gamepadIndex = null;
                // Reset sticks
                document.querySelectorAll('.stick').forEach(element => {
                    element.classList.remove('pressed');
                    const zDistance = element.dataset.zDistance || 0;
                    element.style.transform = `translate(0px, 0px) translateZ(${-zDistance}px) rotateX(0deg) rotateY(0deg)`;
                });
                
                // Reset all other buttons
                document.querySelectorAll('.xbox .trigger, .xbox .bumper, .xbox .back, .xbox .start, .xbox .button, .xbox .face').forEach(element => {
                    element.classList.remove('pressed');
                });
            }
        }

        // --- STICK PHYSICS (Bending/Tilting) ---
        function applyStickPhysics(element, x, y, TRAVEL_FACTOR, TILT_FACTOR, layerIndex) {
            if (Math.abs(x) < 0.1) x = 0;
            if (Math.abs(y) < 0.1) y = 0;

            const BASE_TRAVEL_DISTANCE = 28; 
            const BASE_TILT_ANGLE = 28;      
            const Z_SEPARATION_UNIT = 4;
            
            const Z_DISTANCE = Z_SEPARATION_UNIT * layerIndex;
            
            const TRAVEL_DISTANCE = BASE_TRAVEL_DISTANCE * TRAVEL_FACTOR;
            const TILT_ANGLE = BASE_TILT_ANGLE * TILT_FACTOR;

            const moveX = x * TRAVEL_DISTANCE;
            const moveY = y * TRAVEL_DISTANCE;
            
            const rotateX = y * TILT_ANGLE; 
            const rotateY = x * TILT_ANGLE;

            element.style.transform = `translate(${moveX}px, ${moveY}px) translateZ(${-Z_DISTANCE}px) rotateX(${-rotateX}deg) rotateY(${rotateY}deg)`;

            element.dataset.zDistance = Z_DISTANCE;
        }

        function updateStatus() {
            if (gamepadIndex === null) return;

            const gamepad = navigator.getGamepads()[gamepadIndex];
            if (!gamepad) return;

            // --- 1. Digital Button Update (ABXY, Start/Back, Bumpers, Triggers, L3/R3) ---
            gamepad.buttons.forEach((button, index) => {
                const selector = buttonMap[index];
                
                // Stick Button (L3/R3) Handling
                if (selector && (selector.includes('.stick.main.left') || selector.includes('.stick.main.right'))) {
                    const genericSelector = selector.replace('.main', '');
                    const elements = document.querySelectorAll('.stick-container' + genericSelector.replace('.stick', ' .stick'));
                    if (elements.length > 0) {
                        elements.forEach(element => {
                            if (button.pressed) {
                                element.classList.add('pressed');
                            } else {
                                element.classList.remove('pressed');
                            }
                        });
                    }
                } 
                // All other digital buttons (ABXY, Start/Back, Triggers/Bumpers)
                else {
                    const element = controllerElements[selector]; 
                    if (element) {
                        // Check for digital pressed OR analog trigger value
                        const isPressed = button.pressed || (index >= 6 && index <= 7 && button.value > 0.1); 
                        if (isPressed) {
                            element.classList.add('pressed');
                        } else {
                            element.classList.remove('pressed');
                        }
                    }
                }
            });

            // --- 2. D-pad Check (Robust Axis AND Button Fallback) ---

            // Check A: Axis Polling (Preferred W3C/Browser Standard)
            const AXIS_DPAD_X = gamepad.axes[6] !== undefined ? gamepad.axes[6] : gamepad.axes[4]; 
            const AXIS_DPAD_Y = gamepad.axes[7] !== undefined ? gamepad.axes[7] : gamepad.axes[5]; 
            
            let dpadPressed = false;

            // Horizontal D-pad (X-axis)
            if (AXIS_DPAD_X === -1 || AXIS_DPAD_X < -0.5) {
                controllerElements['.face.left'].classList.add('pressed');
                controllerElements['.face.right'].classList.remove('pressed');
                dpadPressed = true;
            } else if (AXIS_DPAD_X === 1 || AXIS_DPAD_X > 0.5) {
                controllerElements['.face.left'].classList.remove('pressed');
                controllerElements['.face.right'].classList.add('pressed');
                dpadPressed = true;
            } else {
                controllerElements['.face.left'].classList.remove('pressed');
                controllerElements['.face.right'].classList.remove('pressed');
            }

            // Vertical D-pad (Y-axis)
            if (AXIS_DPAD_Y === -1 || AXIS_DPAD_Y < -0.5) {
                controllerElements['.face.up'].classList.add('pressed');
                controllerElements['.face.down'].classList.remove('pressed');
                dpadPressed = true;
            } else if (AXIS_DPAD_Y === 1 || AXIS_DPAD_Y > 0.5) {
                controllerElements['.face.up'].classList.remove('pressed');
                controllerElements['.face.down'].classList.add('pressed');
                dpadPressed = true;
            } else {
                controllerElements['.face.up'].classList.remove('pressed');
                controllerElements['.face.down'].classList.remove('pressed');
            }
            
            // Check B: Button Polling (Fallback for specific controllers that don't report axes correctly)
            // Only run if the Axis check didn't already register a press
            if (!dpadPressed) {
                // Button 12: D-pad Up
                if (gamepad.buttons[12] && gamepad.buttons[12].pressed) {
                    controllerElements['.face.up'].classList.add('pressed');
                }
                // Button 13: D-pad Down
                if (gamepad.buttons[13] && gamepad.buttons[13].pressed) {
                    controllerElements['.face.down'].classList.add('pressed');
                }
                // Button 14: D-pad Left
                if (gamepad.buttons[14] && gamepad.buttons[14].pressed) {
                    controllerElements['.face.left'].classList.add('pressed');
                }
                // Button 15: D-pad Right
                if (gamepad.buttons[15] && gamepad.buttons[15].pressed) {
                    controllerElements['.face.right'].classList.add('pressed');
                }
                
                // If the D-pad is not pressed, ensure the classes are removed
                if (!gamepad.buttons[12]?.pressed && !gamepad.buttons[13]?.pressed) {
                    controllerElements['.face.up'].classList.remove('pressed');
                    controllerElements['.face.down'].classList.remove('pressed');
                }
                if (!gamepad.buttons[14]?.pressed && !gamepad.buttons[15]?.pressed) {
                    controllerElements['.face.left'].classList.remove('pressed');
                    controllerElements['.face.right'].classList.remove('pressed');
                }
            }


            // --- 3. Stick Physics Update ---
            const AXIS_LX = gamepad.axes[0];
            const AXIS_LY = gamepad.axes[1];
            const AXIS_RX = gamepad.axes[2];
            const AXIS_RY = gamepad.axes[3];
            
            const STACK_FACTORS = [1.0, 0.96, 0.92, 0.88, 0.84]; 
            
            leftStickLayers.forEach((element, index) => {
                if (element) {
                    const factor = STACK_FACTORS[index];
                    applyStickPhysics(element, AXIS_LX, AXIS_LY, factor, factor, index);
                }
            });

            rightStickLayers.forEach((element, index) => {
                if (element) {
                    const factor = STACK_FACTORS[index];
                    applyStickPhysics(element, AXIS_RX, AXIS_RY, factor, factor, index);
                }
            });

            requestAnimationFrame(updateStatus);
        }

        window.addEventListener('gamepadconnected', connectHandler);
        window.addEventListener('gamepaddisconnected', disconnectHandler);

        // --- Function to set the initial transform (rest position + Z-separation) ---
        function setInitialStickTransforms() {
            const Z_SEPARATION_UNIT = 4; 

            leftStickLayers.forEach((element, index) => {
                const Z_DISTANCE = Z_SEPARATION_UNIT * index;
                element.style.transform = `translate(0px, 0px) translateZ(${-Z_DISTANCE}px) rotateX(0deg) rotateY(0deg)`;
                element.dataset.zDistance = Z_DISTANCE;
            });
            rightStickLayers.forEach((element, index) => {
                const Z_DISTANCE = Z_SEPARATION_UNIT * index;
                element.style.transform = `translate(0px, 0px) translateZ(${-Z_DISTANCE}px) rotateX(0deg) rotateY(0deg)`;
                element.dataset.zDistance = Z_DISTANCE;
            });
        }
        
        setInitialStickTransforms();

        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                connectHandler({ gamepad: gamepads[i] });
                break;
            }
        }
    </script>
</body>
</html>
